---
id: week-04
title: Services, Actions & Launch Files
sidebar_label: Services, Actions & Launch Files
sidebar_position: 4
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Week 4: ROS 2 Services, Actions & Launch Files

## Learning Outcomes

By the end of this module, you will be able to:

1. **Design** custom ROS 2 service and action definitions
2. **Implement** synchronous request-response patterns with services
3. **Create** asynchronous goal-based tasks with actions
4. **Write** Python and XML launch files for complex multi-node systems
5. **Use** parameters and configurations for flexible robot behavior
6. **Debug** multi-node systems with ROS 2 CLI tools

---

## 4.1 Services: Synchronous Communication

### When to Use Services

**Services** provide synchronous, one-to-one communication. A client sends a request and waits for a response.

**Use Cases**:
- Compute operations (IK solver, path planning)
- State queries (battery level, joint limits)
- Trigger actions (reset simulation, save map)
- Configuration changes (set control gains)

**vs. Topics**:
- Topics: Asynchronous, many-to-many, continuous data streams
- Services: Synchronous, one-to-one, occasional requests

---

## 4.2 Custom Service Definitions

### Creating .srv Files

Services are defined in `.srv` files with request and response fields:

```
# ComputeIK.srv
# Request: Target end-effector pose
geometry_msgs/Pose target_pose
---
# Response: Joint angles and success flag
float64[] joint_angles
bool success
string message
```

**Structure**:
- Above `---`: Request fields
- Below `---`: Response fields

### Complete Package Structure

```
humanoid_interfaces/
├── CMakeLists.txt
├── package.xml
├── srv/
│   ├── ComputeIK.srv
│   ├── ResetRobot.srv
│   └── GetBatteryStatus.srv
├── action/
│   └── ReachPose.action
└── msg/
    └── RobotStatus.msg
```

### CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.8)
project(humanoid_interfaces)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# Find dependencies
find_package(ament_cmake REQUIRED)
find_package(rosidl_default_generators REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(std_msgs REQUIRED)

# Generate interfaces
rosidl_generate_interfaces(${PROJECT_NAME}
  "srv/ComputeIK.srv"
  "srv/ResetRobot.srv"
  "srv/GetBatteryStatus.srv"
  "action/ReachPose.action"
  "msg/RobotStatus.msg"
  DEPENDENCIES geometry_msgs std_msgs
)

ament_package()
```

### package.xml

```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>humanoid_interfaces</name>
  <version>0.1.0</version>
  <description>Custom interfaces for humanoid robot</description>
  <maintainer email="student@piaic.org">PIAIC Student</maintainer>
  <license>MIT</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <build_depend>rosidl_default_generators</build_depend>
  <build_depend>geometry_msgs</build_depend>
  <build_depend>std_msgs</build_depend>

  <exec_depend>rosidl_default_runtime</exec_depend>
  <exec_depend>geometry_msgs</exec_depend>
  <exec_depend>std_msgs</exec_depend>

  <member_of_group>rosidl_interface_packages</member_of_group>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
```

### Build Custom Interfaces

```bash
cd ~/ros2_ws
colcon build --packages-select humanoid_interfaces
source install/setup.bash

# Verify
ros2 interface show humanoid_interfaces/srv/ComputeIK
```

---

## 4.3 Service Server Implementation

### Inverse Kinematics Service

```python
#!/usr/bin/env python3
"""
Inverse kinematics service for humanoid arm.
Computes joint angles for a target end-effector pose.

Reference: Siciliano et al., "Robotics: Modelling, Planning and Control"
"""

import rclpy
from rclpy.node import Node
from humanoid_interfaces.srv import ComputeIK
from geometry_msgs.msg import Pose
import numpy as np
from scipy.optimize import minimize


class IKServiceNode(Node):
    """Inverse kinematics service for 7-DOF arm."""

    def __init__(self):
        super().__init__('ik_service')

        # Create service
        self.srv = self.create_service(
            ComputeIK,
            'compute_ik',
            self.compute_ik_callback
        )

        # Robot parameters (DH parameters for 7-DOF arm)
        self.num_joints = 7

        # Joint limits (radians)
        self.joint_limits = np.array([
            [-2.96, 2.96],  # Shoulder pitch
            [-2.09, 2.09],  # Shoulder roll
            [-2.96, 2.96],  # Shoulder yaw
            [-2.09, 2.09],  # Elbow
            [-2.96, 2.96],  # Wrist pitch
            [-2.09, 2.09],  # Wrist roll
            [-2.96, 2.96]   # Wrist yaw
        ])

        self.get_logger().info('IK service ready')

    def forward_kinematics(self, joint_angles):
        """
        Compute end-effector pose from joint angles.

        Args:
            joint_angles: Array of 7 joint angles (radians)

        Returns:
            4x4 homogeneous transformation matrix
        """
        # Simplified FK (replace with actual DH parameters)
        # This is a placeholder - real implementation would use
        # Denavit-Hartenberg parameters

        T = np.eye(4)

        # Link lengths (meters)
        L = [0.1, 0.3, 0.05, 0.3, 0.05, 0.1, 0.05]

        x, y, z = 0.0, 0.0, 0.0

        # Simplified 2D FK for demonstration
        angle_sum = 0.0
        for i in range(self.num_joints):
            angle_sum += joint_angles[i]
            x += L[i] * np.cos(angle_sum)
            z += L[i] * np.sin(angle_sum)

        T[0, 3] = x
        T[1, 3] = y
        T[2, 3] = z

        return T

    def compute_ik_callback(self, request, response):
        """
        Service callback: Solve IK for target pose.

        Args:
            request: ComputeIK.Request with target_pose

        Returns:
            response: ComputeIK.Response with joint_angles, success, message
        """
        target_pose = request.target_pose

        self.get_logger().info(
            f'IK request: target=({target_pose.position.x:.2f}, '
            f'{target_pose.position.y:.2f}, {target_pose.position.z:.2f})'
        )

        # Extract target position
        target_pos = np.array([
            target_pose.position.x,
            target_pose.position.y,
            target_pose.position.z
        ])

        # Solve IK using numerical optimization
        def objective(q):
            """Cost function: Distance to target."""
            T = self.forward_kinematics(q)
            current_pos = T[:3, 3]
            error = np.linalg.norm(current_pos - target_pos)
            return error

        # Initial guess (current configuration)
        q0 = np.zeros(self.num_joints)

        # Optimization bounds
        bounds = self.joint_limits.tolist()

        # Solve
        result = minimize(
            objective,
            q0,
            method='SLSQP',
            bounds=bounds,
            options={'maxiter': 100}
        )

        # Check success
        if result.success and result.fun < 0.01:  # 1cm tolerance
            response.joint_angles = result.x.tolist()
            response.success = True
            response.message = f'IK solved! Error: {result.fun:.4f}m'
            self.get_logger().info(response.message)
        else:
            response.joint_angles = []
            response.success = False
            response.message = f'IK failed. Error: {result.fun:.4f}m'
            self.get_logger().warn(response.message)

        return response


def main(args=None):
    rclpy.init(args=args)
    node = IKServiceNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### Service Client

```python
#!/usr/bin/env python3
"""
IK service client example.
Requests joint angles for a target pose.
"""

import rclpy
from rclpy.node import Node
from humanoid_interfaces.srv import ComputeIK
from geometry_msgs.msg import Pose


class IKClientNode(Node):
    """Client for IK service."""

    def __init__(self):
        super().__init__('ik_client')

        # Create client
        self.client = self.create_client(ComputeIK, 'compute_ik')

        # Wait for service to be available
        while not self.client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Waiting for IK service...')

        self.get_logger().info('IK service connected')

    def send_request(self, x, y, z):
        """Send IK request."""
        request = ComputeIK.Request()

        # Set target pose
        request.target_pose.position.x = x
        request.target_pose.position.y = y
        request.target_pose.position.z = z
        request.target_pose.orientation.w = 1.0  # No rotation

        self.get_logger().info(f'Sending IK request: ({x}, {y}, {z})')

        # Call service (blocking)
        future = self.client.call_async(request)
        rclpy.spin_until_future_complete(self, future)

        if future.result() is not None:
            response = future.result()

            if response.success:
                self.get_logger().info(f'Success! Joint angles: {response.joint_angles}')
            else:
                self.get_logger().error(f'Failed: {response.message}')

            return response
        else:
            self.get_logger().error('Service call failed')
            return None


def main(args=None):
    rclpy.init(args=args)
    node = IKClientNode()

    # Test IK for target (0.5, 0.0, 0.3)
    node.send_request(0.5, 0.0, 0.3)

    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

**Usage**:
```bash
# Terminal 1: Start service
python3 ik_service_node.py

# Terminal 2: Call service
python3 ik_client_node.py
```

---

## 4.4 Actions: Goal-Based Communication

### When to Use Actions

**Actions** provide asynchronous, goal-based communication with feedback. Useful for long-running tasks.

**Use Cases**:
- Navigate to pose (send goal, get progress feedback)
- Follow trajectory (execute motion, report completion %)
- Grasp object (approach, close gripper, confirm grasp)

**Components**:
- **Goal**: Target state to achieve
- **Feedback**: Periodic progress updates
- **Result**: Final outcome (success/failure, final state)

---

## 4.5 Custom Action Definitions

### Action File Format

```
# ReachPose.action

# Goal: Target end-effector pose
geometry_msgs/Pose target_pose
---
# Result: Final reached pose and success
geometry_msgs/Pose final_pose
bool success
string message
---
# Feedback: Current pose and distance to goal
geometry_msgs/Pose current_pose
float64 distance_remaining
float64 percent_complete
```

**Structure**:
- Section 1 (above first `---`): Goal
- Section 2 (between `---`): Result
- Section 3 (below second `---`): Feedback

---

## 4.6 Action Server Implementation

```python
#!/usr/bin/env python3
"""
Action server: Reach target pose with feedback.
Simulates smooth motion with progress updates.
"""

import rclpy
from rclpy.node import Node
from rclpy.action import ActionServer, CancelResponse, GoalResponse
from humanoid_interfaces.action import ReachPose
from geometry_msgs.msg import Pose
import numpy as np
import time


class ReachPoseActionServer(Node):
    """Action server for reaching target poses."""

    def __init__(self):
        super().__init__('reach_pose_action_server')

        # Create action server
        self._action_server = ActionServer(
            self,
            ReachPose,
            'reach_pose',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            cancel_callback=self.cancel_callback
        )

        # Current pose (simulated)
        self.current_pose = Pose()
        self.current_pose.position.x = 0.0
        self.current_pose.position.y = 0.0
        self.current_pose.position.z = 0.5
        self.current_pose.orientation.w = 1.0

        self.get_logger().info('Reach Pose action server ready')

    def goal_callback(self, goal_request):
        """Accept or reject incoming goals."""
        self.get_logger().info('Received goal request')
        return GoalResponse.ACCEPT

    def cancel_callback(self, goal_handle):
        """Handle cancel requests."""
        self.get_logger().info('Received cancel request')
        return CancelResponse.ACCEPT

    async def execute_callback(self, goal_handle):
        """Execute the reach pose action."""
        self.get_logger().info('Executing goal...')

        # Extract target pose
        target = goal_handle.request.target_pose

        # Calculate distance
        start_pos = np.array([
            self.current_pose.position.x,
            self.current_pose.position.y,
            self.current_pose.position.z
        ])

        target_pos = np.array([
            target.position.x,
            target.position.y,
            target.position.z
        ])

        total_distance = np.linalg.norm(target_pos - start_pos)

        # Simulate motion (100 steps)
        num_steps = 100
        feedback_msg = ReachPose.Feedback()

        for i in range(num_steps):
            # Check if cancelled
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                result = ReachPose.Result()
                result.success = False
                result.message = 'Goal cancelled'
                return result

            # Interpolate current position
            alpha = (i + 1) / num_steps
            current_pos = start_pos + alpha * (target_pos - start_pos)

            self.current_pose.position.x = current_pos[0]
            self.current_pose.position.y = current_pos[1]
            self.current_pose.position.z = current_pos[2]

            # Compute feedback
            distance_remaining = np.linalg.norm(target_pos - current_pos)

            feedback_msg.current_pose = self.current_pose
            feedback_msg.distance_remaining = distance_remaining
            feedback_msg.percent_complete = alpha * 100.0

            # Publish feedback
            goal_handle.publish_feedback(feedback_msg)

            self.get_logger().info(
                f'Progress: {alpha*100:.1f}% | Remaining: {distance_remaining:.3f}m'
            )

            # Simulate execution time
            time.sleep(0.05)  # 50ms per step = 5 seconds total

        # Success
        goal_handle.succeed()

        result = ReachPose.Result()
        result.final_pose = self.current_pose
        result.success = True
        result.message = 'Target reached successfully'

        self.get_logger().info('Goal succeeded!')
        return result


def main(args=None):
    rclpy.init(args=args)
    node = ReachPoseActionServer()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### Action Client

```python
#!/usr/bin/env python3
"""
Action client: Send goal and monitor feedback.
"""

import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from humanoid_interfaces.action import ReachPose
from geometry_msgs.msg import Pose


class ReachPoseActionClient(Node):
    """Client for reach pose action."""

    def __init__(self):
        super().__init__('reach_pose_action_client')

        # Create action client
        self._action_client = ActionClient(
            self,
            ReachPose,
            'reach_pose'
        )

        self.get_logger().info('Waiting for action server...')
        self._action_client.wait_for_server()
        self.get_logger().info('Action server connected')

    def send_goal(self, x, y, z):
        """Send reach pose goal."""
        goal_msg = ReachPose.Goal()

        # Set target pose
        goal_msg.target_pose.position.x = x
        goal_msg.target_pose.position.y = y
        goal_msg.target_pose.position.z = z
        goal_msg.target_pose.orientation.w = 1.0

        self.get_logger().info(f'Sending goal: ({x}, {y}, {z})')

        # Send goal
        self._send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback
        )

        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        """Handle goal acceptance."""
        goal_handle = future.result()

        if not goal_handle.accepted:
            self.get_logger().error('Goal rejected')
            return

        self.get_logger().info('Goal accepted')

        # Get result
        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def feedback_callback(self, feedback_msg):
        """Handle feedback."""
        feedback = feedback_msg.feedback
        self.get_logger().info(
            f'Feedback: {feedback.percent_complete:.1f}% complete | '
            f'{feedback.distance_remaining:.3f}m remaining'
        )

    def get_result_callback(self, future):
        """Handle final result."""
        result = future.result().result

        if result.success:
            self.get_logger().info(f'Success! {result.message}')
        else:
            self.get_logger().error(f'Failed: {result.message}')


def main(args=None):
    rclpy.init(args=args)
    node = ReachPoseActionClient()

    # Send goal to (0.5, 0.2, 0.7)
    node.send_goal(0.5, 0.2, 0.7)

    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

**Usage**:
```bash
# Terminal 1: Action server
python3 reach_pose_action_server.py

# Terminal 2: Action client
python3 reach_pose_action_client.py
```

---

## 4.7 Launch Files

### Why Launch Files?

**Problem**: Manually starting 10+ nodes is tedious and error-prone.

**Solution**: Launch files automate multi-node startup with configurations.

### Python Launch File

```python
#!/usr/bin/env python3
"""
Launch file for humanoid robot system.
Starts: IK service, action server, teleoperation, RViz.
"""

from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument, ExecuteProcess
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.substitutions import FindPackageShare


def generate_launch_description():
    # Declare arguments
    use_sim_time = DeclareLaunchArgument(
        'use_sim_time',
        default_value='false',
        description='Use simulation time'
    )

    robot_name = DeclareLaunchArgument(
        'robot_name',
        default_value='humanoid_01',
        description='Robot namespace'
    )

    # Get launch configuration
    use_sim_time_value = LaunchConfiguration('use_sim_time')
    robot_name_value = LaunchConfiguration('robot_name')

    # IK Service
    ik_service = Node(
        package='humanoid_control',
        executable='ik_service_node',
        name='ik_service',
        namespace=robot_name_value,
        parameters=[{'use_sim_time': use_sim_time_value}],
        output='screen'
    )

    # Action Server
    action_server = Node(
        package='humanoid_control',
        executable='reach_pose_action_server',
        name='reach_pose_server',
        namespace=robot_name_value,
        parameters=[{'use_sim_time': use_sim_time_value}],
        output='screen'
    )

    # Teleoperation
    teleop = Node(
        package='humanoid_control',
        executable='teleop_keyboard',
        name='teleop',
        namespace=robot_name_value,
        output='screen',
        prefix='xterm -e'  # Run in separate terminal
    )

    # Robot State Publisher
    robot_description_path = PathJoinSubstitution([
        FindPackageShare('humanoid_description'),
        'urdf',
        'humanoid.urdf.xacro'
    ])

    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        name='robot_state_publisher',
        namespace=robot_name_value,
        parameters=[{
            'use_sim_time': use_sim_time_value,
            'robot_description': ExecuteProcess(
                cmd=['xacro', robot_description_path],
                output='screen'
            )
        }],
        output='screen'
    )

    # RViz
    rviz_config = PathJoinSubstitution([
        FindPackageShare('humanoid_description'),
        'rviz',
        'humanoid.rviz'
    ])

    rviz = Node(
        package='rviz2',
        executable='rviz2',
        name='rviz2',
        arguments=['-d', rviz_config],
        parameters=[{'use_sim_time': use_sim_time_value}],
        output='screen'
    )

    return LaunchDescription([
        use_sim_time,
        robot_name,
        ik_service,
        action_server,
        teleop,
        robot_state_publisher,
        rviz
    ])
```

**Run**:
```bash
ros2 launch humanoid_control humanoid.launch.py

# With arguments
ros2 launch humanoid_control humanoid.launch.py use_sim_time:=true robot_name:=my_robot
```

---

## 4.8 Parameters & Configurations

### Using YAML Config Files

```yaml
# humanoid_config.yaml

/**:
  ros__parameters:
    # IK Service Parameters
    ik_service:
      max_iterations: 100
      tolerance: 0.01  # meters
      joint_limits:
        shoulder_pitch: [-2.96, 2.96]
        shoulder_roll: [-2.09, 2.09]
        elbow: [-2.09, 2.09]

    # Action Server Parameters
    reach_pose_server:
      execution_time: 5.0  # seconds
      feedback_rate: 20.0  # Hz
      position_tolerance: 0.05  # meters

    # Teleoperation Parameters
    teleop:
      linear_speed: 0.5  # m/s
      angular_speed: 1.0  # rad/s
      deadman_button: true
```

### Loading Parameters in Node

```python
class IKServiceNode(Node):
    def __init__(self):
        super().__init__('ik_service')

        # Declare parameters with defaults
        self.declare_parameter('max_iterations', 100)
        self.declare_parameter('tolerance', 0.01)

        # Get parameter values
        self.max_iters = self.get_parameter('max_iterations').value
        self.tolerance = self.get_parameter('tolerance').value

        self.get_logger().info(
            f'IK config: max_iters={self.max_iters}, tol={self.tolerance}'
        )
```

**Load config in launch file**:
```python
ik_service = Node(
    package='humanoid_control',
    executable='ik_service_node',
    parameters=['/path/to/humanoid_config.yaml']
)
```

---

## Exercises

### Basic (40%)
1. **Create** a service `GetJointLimits` that returns joint limits for a given joint name. Test with 3 different joints.

2. **Implement** an action `CountToTen` that counts from 1 to 10, publishing progress feedback every second. Client should print each count.

3. **Write** a launch file that starts 3 nodes: publisher, subscriber, and a transform broadcaster. Use XML format.

### Intermediate (40%)
4. **Modify** the IK service to accept orientation (quaternion) in addition to position. Use actual DH parameters for a 7-DOF arm.

5. **Create** a `FollowTrajectory` action that:
   - Goal: Array of waypoints (poses)
   - Feedback: Current waypoint index, time elapsed
   - Result: Total distance traveled, execution time
   Simulate smooth interpolation between waypoints.

6. **Build** a multi-robot system with namespaces:
   - Launch 2 humanoid robots (`robot_1`, `robot_2`)
   - Each has independent IK service
   - Demonstrate calling services for both robots

### Advanced (20%)
7. **Implement** action preemption: If a new goal arrives while executing, cancel the current goal and start the new one immediately.

8. **Create** a parameter reconfiguration system:
   - Service to update IK tolerance at runtime
   - Log when parameters change
   - Demonstrate changing tolerance from 0.01 to 0.05 during execution

9. **Capstone Prep**: Design service/action interfaces for your Week 13 project:
   - Services: IK, obstacle detection, grasp feasibility
   - Actions: Navigate to pose, grasp object, follow trajectory
   - Write `.srv` and `.action` files
   - Submit interface package

---

## Summary

- **Services**: Synchronous request-response for computations, queries, triggers
- **Actions**: Asynchronous goal-based tasks with feedback and cancellation
- **Custom interfaces**: `.srv` and `.action` files define message structures
- **Launch files**: Automate multi-node startup with configurations
- **Parameters**: YAML files enable flexible, reusable robot configurations
- **Namespaces**: Enable multi-robot systems with isolated communication

**Next**: [Week 5: Advanced ROS 2 Patterns](./week-05)

---


